<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Edit Book</title>
    <style>
        #editor {
            width: 100%;
            height: 93vh;
        }

        body {
            margin: 0;
        }

        label {
            font-family: sans-serif;
            font-size: 14px;
        }

        .btn {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            margin: 1vh 10px 0 10px;
            padding: 5px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 15px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .btn:hover {
            background-color: #45a049;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .container {
            display: flex;
            flex-direction: row;
        }

        .container2 {
            justify-content: space-between;
            display: flex;
            flex-direction: row;
        }

        #dir {
            width: 25%;
            padding: 0px;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 93vh;
            font-family: sans-serif;
        }

        #menu {
            width: 8%;
            padding: 0px;
            border-right: 1px solid #ccc;
            overflow-y: auto;
            height: 93vh;
            font-family: sans-serif;
            outline: none;
        }

        #editor-container {
            width: 67%;
        }

        ul {
            list-style-type: none;
            padding-left: 10px;
        }

        li.verse {
            background-color: #ffffff;
        }

        li.active {
            background-color: #ffff99;
        }

        li.roam-active {
            background-color: #add8e6;
        }

        li.selected {
            background-color: #d3d3d3;
        }

        #file-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            z-index: 1000;
            cursor: pointer;
        }

        #file-menu div {
            padding: 5px 10px;
        }

        #file-menu div:hover {
            background-color: #f0f0f0;
        }

        #file-menu .delete-btn {
            color: #ff0000;
        }

        #file-menu .delete-btn:hover {
            background-color: #ffe6e6;
        }

        #file-input {
            display: none;
        }

        .notification {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: #45a049;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notification.show {
            opacity: 1;
        }
    </style>
    <script src="/ace.js"></script>
    <script src="/keybinding-vim.min.js"></script>
    <script src="/json-source-map.js"></script>
</head>
<body>

<div class="container">
    <div id="dir"></div>
    <div id="menu"></div>
    <div id="editor-container">
        <div id="editor"></div>
    </div>
</div>
<div class="container2">
    <button class="btn" onclick="uploadFile()">Upload File</button>
    <div class="container">
        <button class="btn" onclick="commit()">Commit</button>
        <label class="btn">
            <input type="checkbox" id="vimToggle" onchange="toggleVimMode()"> Vim Mode
        </label>
        <button class="btn" onclick="formatJSON()">Format JSON</button>
    </div>
</div>

<div id="file-menu" style="display: none;">
    <div id="file-menu-copy">Copy</div>
    <div id="file-menu-play">Play</div>
    <div id="file-menu-delete" class="delete-btn">Delete</div>
</div>

<input type="file" id="file-input"/>

<script>
    var editor = ace.edit("editor");
    editor.session.setMode("ace/mode/json");
    editor.setTheme("ace/theme/github");
    editor.commands.addCommand({
        name: "format",
        bindKey: {win: "Shift-Alt-F", mac: "Shift-Option-F"},
        exec: function (_) {
            formatJSON();
        }
    });
    editor.commands.addCommand({
        name: "save",
        bindKey: {win: "Ctrl-S", mac: "Cmd-S"},
        exec: function (_) {
            commit();
        }
    });
    editor.commands.addCommand({
        name: "switchFocus",
        bindKey: {win: "Ctrl-Shift-E", mac: "Command-Shift-E"},
        exec: function (_) {
            document.getElementById('menu').focus();
        }
    });

    var Vim = ace.require("ace/keyboard/vim").Vim;
    Vim.map("<Space>", "<Leader>", "normal");
    Vim.mapCommand("<Leader>fd", "action", "aceCommand", {name: "format"}, {context: "normal"});

    function toggleVimMode() {
        let switchValue = 0;
        if (document.getElementById('vimToggle').checked) {
            switchValue = 1;
        }
        fetch('/setVimMode', {
            method: 'POST',
            body: `${switchValue}`
        });
        if (switchValue === 1) {
            editor.setKeyboardHandler("ace/keyboard/vim");
        } else {
            editor.setKeyboardHandler(null);
        }
    }

    function showNotification(message) {
        let notification = document.getElementById('notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'notification';
            notification.className = 'notification';
            document.body.appendChild(notification);
        }
        notification.textContent = message;
        notification.classList.add('show');
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                notification.remove();
            }, 300);
        }, 2000);
    }

    function formatJSON() {
        var currentValue = editor.getValue();
        try {
            var parsed = JSON.parse(currentValue);
            var cursor = editor.getCursorPosition();
            editor.setValue(JSON.stringify(parsed, null, 2), -1);
            editor.scrollToLine(cursor.row + 1, true, true, () => {
            });
            editor.gotoLine(cursor.row + 1, cursor.column, true);
            editor.focus();
        } catch (e) {
            alert("Invalid JSON: " + e.message);
        }
    }

    var clickedMenu = false;
    var menuItems = [];
    var currentRoamIndex = -1;

    function generateMenu() {
        const menuDiv = document.getElementById('menu');
        menuDiv.innerHTML = ''; // Clear existing menu
        try {
            const bookData = JSON.parse(editor.getValue());
            const map = jsonSourceMap.parse(editor.getValue());
            const pointers = map.pointers;

            if (bookData && bookData.c && Array.isArray(bookData.c)) {
                const menuList = document.createElement('ul');
                bookData.c.forEach((chapter, chapterIndex) => {
                    const chapterPath = `/c/${chapterIndex}`;
                    const chapterPointer = pointers[chapterPath];
                    if (chapterPointer) {
                        const chapterLine = chapterPointer.value.line; // 0-based
                        const chapterItem = document.createElement('li');
                        chapterItem.id = `chapter-${chapterIndex}`;
                        chapterItem.textContent = `C ${chapterIndex + 1}`;
                        chapterItem.style.cursor = 'pointer';
                        chapterItem.navigate = () => {
                            editor.scrollToLine(chapterLine, true, true, () => {
                            });
                            editor.gotoLine(chapterLine + 1, 0, true);
                            editor.focus();
                            clickedMenu = true;
                        };
                        chapterItem.onclick = (event) => {
                            event.stopPropagation();
                            currentRoamIndex = menuItems.indexOf(chapterItem);
                            highlightRoam();
                            menuDiv.focus();
                        };
                        chapterItem.ondblclick = (event) => {
                            event.stopPropagation();
                            chapterItem.navigate();
                        };
                        menuList.appendChild(chapterItem);

                        if (chapter.v && Array.isArray(chapter.v)) {
                            const verseList = document.createElement('ul');
                            chapter.v.forEach((verse, verseIndex) => {
                                const versePath = `/c/${chapterIndex}/v/${verseIndex}`;
                                const versePointer = pointers[versePath];
                                if (versePointer) {
                                    const verseLine = versePointer.value.line;
                                    const verseItem = document.createElement('li');
                                    verseItem.id = `verse-${chapterIndex}-${verseIndex}`;
                                    verseItem.textContent = `V ${verseIndex + 1}`;
                                    verseItem.classList.add("verse");
                                    verseItem.style.cursor = 'pointer';
                                    verseItem.navigate = () => {
                                        editor.scrollToLine(verseLine, true, true, () => {
                                        });
                                        editor.gotoLine(verseLine + 1, 0, true);
                                        editor.focus();
                                        clickedMenu = true;
                                    };
                                    verseItem.onclick = (event) => {
                                        event.stopPropagation();
                                        currentRoamIndex = menuItems.indexOf(verseItem);
                                        highlightRoam();
                                        menuDiv.focus();
                                    };
                                    verseItem.ondblclick = (event) => {
                                        event.stopPropagation();
                                        verseItem.navigate();
                                    };
                                    verseList.appendChild(verseItem);
                                }
                            });
                            chapterItem.appendChild(verseList);
                        }
                    }
                });
                menuDiv.appendChild(menuList);
                menuItems = Array.from(menuDiv.querySelectorAll('li'));
            }
        } catch (err) {
            console.error("Error parsing JSON for menu:", err);
        }
    }

    function highlightRoam() {
        menuItems.forEach(item => item.classList.remove('roam-active'));
        if (currentRoamIndex >= 0 && currentRoamIndex < menuItems.length) {
            menuItems[currentRoamIndex].classList.add('roam-active');
            menuItems[currentRoamIndex].scrollIntoView({block: 'nearest'});
        }
    }

    function updateMenuHighlight() {
        try {
            const bookData = JSON.parse(editor.getValue());
            const map = jsonSourceMap.parse(editor.getValue());
            const pointers = map.pointers;
            const currentRow = editor.selection.getCursor().row;

            // Remove existing active classes
            document.querySelectorAll('#menu li.active').forEach(el => el.classList.remove('active'));

            // Find current chapter and verse
            let selectedChapter = -1;
            let selectedVerse = -1;
            for (let chapterIndex = 0; chapterIndex < bookData.c.length; chapterIndex++) {
                const chapterPath = `/c/${chapterIndex}`;
                const pointer = pointers[chapterPath];
                if (pointer && currentRow >= pointer.value.line && currentRow <= pointer.valueEnd.line) {
                    selectedChapter = chapterIndex;

                    const chapter = bookData.c[chapterIndex];
                    if (chapter.v && Array.isArray(chapter.v)) {
                        for (let verseIndex = 0; verseIndex < chapter.v.length; verseIndex++) {
                            const versePath = `/c/${chapterIndex}/v/${verseIndex}`;
                            const vPointer = pointers[versePath];
                            if (vPointer && currentRow >= vPointer.value.line && currentRow <= vPointer.valueEnd.line) {
                                selectedVerse = verseIndex;
                                break;
                            }
                        }
                    }
                    break;
                }
            }

            let activeEl = null;
            if (selectedVerse !== -1) {
                const verseEl = document.getElementById(`verse-${selectedChapter}-${selectedVerse}`);
                if (verseEl) {
                    verseEl.classList.add('active');
                    activeEl = verseEl;
                }
            } else if (selectedChapter !== -1) {
                const chapterEl = document.getElementById(`chapter-${selectedChapter}`);
                if (chapterEl) {
                    chapterEl.classList.add('active');
                    activeEl = chapterEl;
                }
            }

            if (activeEl) {
                if (clickedMenu) {
                    clickedMenu = false;
                } else {
                    activeEl.scrollIntoView({block: 'center'});
                }
            }

            const newUrl = new URL(window.location);
            if (selectedChapter !== -1) {
                newUrl.searchParams.set('c', selectedChapter + 1);
                if (selectedVerse !== -1) {
                    newUrl.searchParams.set('v', selectedVerse + 1);
                } else {
                    newUrl.searchParams.delete('v');
                }
            } else {
                newUrl.searchParams.delete('c');
                newUrl.searchParams.delete('v');
            }
            history.pushState({}, '', newUrl);
        } catch (err) {
            console.error("Error updating menu highlight:", err);
        }
    }

    function updateFileHighlight() {
        try {
            const bookData = JSON.parse(editor.getValue());
            const map = jsonSourceMap.parse(editor.getValue());
            const pointers = map.pointers;
            const currentRow = editor.selection.getCursor().row;

            let containingPath = '';
            let maxLength = 0;
            for (let p in pointers) {
                const ptr = pointers[p];
                if (ptr.value && currentRow >= ptr.value.line && currentRow <= ptr.valueEnd.line) {
                    if (p.length > maxLength) {
                        maxLength = p.length;
                        containingPath = p;
                    }
                }
            }

            function getUFromPath(path) {
                let segments = path.split('/').slice(1);
                let current = bookData;
                for (let seg of segments) {
                    if (seg) current = current[seg];
                }
                while (true) {
                    if (current.d && Array.isArray(current.d)) {
                        return current.d.map(item => item.u).filter(u => u);
                    }
                    if (segments.length === 0) break;
                    segments.pop();
                    current = bookData;
                    for (let seg of segments) {
                        current = current[seg];
                    }
                }
                return [];
            }

            const us = getUFromPath(containingPath);
            document.querySelectorAll('#dir li.active').forEach(item => item.classList.remove('active'));
            let firstMatched = null;
            us.forEach(u => {
                const dirItems = document.querySelectorAll('#dir li');
                for (let item of dirItems) {
                    if (item.textContent === u) {
                        item.classList.add('active');
                        if (!firstMatched) firstMatched = item;
                        break;
                    }
                }
            });
            if (firstMatched) {
                firstMatched.scrollIntoView({block: 'center'});
            }
        } catch (err) {
            console.error("Error updating file highlight:", err);
        }
    }

    function debounce(func, wait) {
        let timeout;
        return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    let timeout;
    editor.on('change', () => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            generateMenu();
            updateMenuHighlight();
        }, 500);
    });

    editor.on('changeSelection', debounce(() => {
        updateMenuHighlight();
        updateFileHighlight();
    }, 100));

    const menuDiv = document.getElementById('menu');
    menuDiv.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (currentRoamIndex < menuItems.length - 1) {
                currentRoamIndex++;
            } else {
                currentRoamIndex = 0;
            }
            highlightRoam();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (currentRoamIndex > 0) {
                currentRoamIndex--;
            } else {
                currentRoamIndex = menuItems.length - 1;
            }
            highlightRoam();
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (currentRoamIndex >= 0 && currentRoamIndex < menuItems.length) {
                const item = menuItems[currentRoamIndex];
                if (item.navigate) {
                    item.navigate();
                }
            }
        } else if (e.key === 'Escape') {
            e.preventDefault();
            editor.focus();
        }
    });

    menuDiv.addEventListener('focus', () => {
        clearFileSelected();
        if (currentRoamIndex >= 0) {
            return;
        }
        const active = menuDiv.querySelector('li.active');
        if (active && menuItems.includes(active)) {
            currentRoamIndex = menuItems.indexOf(active);
        } else if (menuItems.length > 0) {
            currentRoamIndex = 0;
        }
        highlightRoam();
    });

    menuDiv.addEventListener('blur', () => {
        menuItems.forEach(item => item.classList.remove('roam-active'));
        currentRoamIndex = -1;
    });

    // Add shortcut for switching focus: Command+Shift+E (Mac) or Ctrl+Shift+E (Windows)
    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toUpperCase() === 'E') {
            e.preventDefault();
            if (document.activeElement === menuDiv) {
                editor.focus();
            } else {
                menuDiv.focus();
            }
        }
    });

    const fileMenu = document.getElementById('file-menu');
    let fileSelectedPath = '';
    let fileSelectedLi = null;

    function clearFileSelected() {
        fileMenu.style.display = 'none';
        if (fileSelectedLi) {
            fileSelectedLi.classList.remove('selected');
            fileSelectedLi = null;
        }
    }

    document.addEventListener('click', (event) => {
        if (!fileMenu.contains(event.target)) {
            clearFileSelected();
        }
    });

    function copyText(str) {
        const textarea = document.createElement('textarea');
        textarea.value = str;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
            document.execCommand('copy');
            return true;
        } catch (err) {
            return false;
        } finally {
            document.body.removeChild(textarea);
        }
    }

    document.getElementById('file-menu-copy').addEventListener('click', () => {
        const path = fileSelectedPath;
        clearFileSelected();
        if (path) {
            if (copyText(path)) {
                showNotification('Path copied to clipboard!');
            } else {
                showNotification('Failed to copy path.');
            }
        } else {
            console.warn('No file selected.');
            showNotification('No file selected.');
        }
    });

    document.getElementById('file-menu-play').addEventListener('click', () => {
        const playUrl = `/play?path=${encodeURIComponent(fileSelectedPath)}`;
        if (fileSelectedPath.endsWith('.mp3') || fileSelectedPath.endsWith('.mp4')) {
            window.open(playUrl, 'mediaPlayer', 'width=400,height=200');
        } else {
            const link = document.createElement('a');
            link.href = playUrl;
            link.download = fileSelectedPath.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        clearFileSelected();
    });

    document.getElementById('file-menu-delete').addEventListener('click', async () => {
        const confirmDelete = confirm(`Are you sure you want to delete ${fileSelectedPath}?`);
        if (confirmDelete) {
            try {
                const res = await fetch(`/delete?path=${encodeURIComponent(fileSelectedPath)}`, {
                    method: 'POST',
                });
                const text = await res.text();
                alert("Server response: " + text);
                clearFileSelected();
                initFiles();
            } catch (err) {
                alert("Error deleting file: " + err);
            }
        }
        clearFileSelected();
    });

    initFiles();
    initBook();
    initVimMode();

    async function initFiles() {
        try {
            const res = await fetch('/browse', {
                method: 'POST',
            });
            const paths = await res.json();
            const dirDiv = document.getElementById('dir');
            dirDiv.innerHTML = '';

            const ul = document.createElement('ul');
            paths.forEach(key => {
                const li = document.createElement('li');
                li.textContent = key;
                li.style.cursor = 'pointer';
                li.onclick = (event) => {
                    event.stopPropagation();
                    if (fileSelectedLi) fileSelectedLi.classList.remove('selected');
                    li.classList.add('selected');
                    fileSelectedLi = li;
                    fileSelectedPath = key;
                    document.getElementById('file-menu-play').textContent = key.endsWith('.mp3') || key.endsWith('.mp4') ? 'Play' : 'Download';
                    fileMenu.style.display = 'block';
                    fileMenu.style.left = `${event.pageX}px`;
                    fileMenu.style.top = `${event.pageY}px`;
                };
                ul.appendChild(li);
            });
            dirDiv.appendChild(ul);
        } catch (err) {
            console.error("Error fetching files:", err);
        }
    }

    async function initBook() {
        try {
            const res = await fetch('/book', {
                method: 'POST',
            });
            const initialValue = await res.text();
            try {
                var parsed = JSON.parse(initialValue);
                editor.setValue(JSON.stringify(parsed, null, 2), -1);
            } catch (e) {
                console.error("Error pretty-printing JSON:", e);
            }
            generateMenu();

            const urlParams = new URLSearchParams(window.location.search);
            const c = urlParams.get('c');
            const v = urlParams.get('v');
            if (c) {
                const chapterIndex = parseInt(c, 10) - 1;
                if (!isNaN(chapterIndex)) {
                    const map = jsonSourceMap.parse(editor.getValue());
                    const pointers = map.pointers;
                    const chapterPath = `/c/${chapterIndex}`;
                    const chapterPointer = pointers[chapterPath];
                    if (chapterPointer) {
                        editor.scrollToLine(chapterPointer.value.line, true, true, () => {
                        });
                        editor.gotoLine(chapterPointer.value.line + 1, 0, true);
                        editor.focus();
                    }
                    if (v) {
                        const verseIndex = parseInt(v, 10) - 1;
                        if (!isNaN(verseIndex)) {
                            const versePath = `/c/${chapterIndex}/v/${verseIndex}`;
                            const versePointer = pointers[versePath];
                            if (versePointer) {
                                editor.scrollToLine(versePointer.value.line, true, true, () => {
                                });
                                editor.gotoLine(versePointer.value.line + 1, 0, true);
                                editor.focus();
                            }
                        }
                    }
                }
            }
            updateMenuHighlight();
        } catch (err) {
            alert("Error sending data: " + err);
        }
    }

    async function initVimMode() {
        const res = await fetch('/getVimMode', {
            method: 'POST',
        });
        const switchValue = await res.text();
        if (switchValue === '1') {
            document.getElementById('vimToggle').checked = true;
            editor.setKeyboardHandler("ace/keyboard/vim");
        } else {
            editor.setKeyboardHandler(null);
        }
    }

    async function commit() {
        const sure = confirm("Are you sure you want to commit the current changes?");
        if (!sure) {
            return;
        }
        const data = editor.getValue();
        try {
            const res = await fetch('/commit', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: data
            });
            const text = await res.text();
            alert(text);
        } catch (err) {
            alert("Error sending data: " + err);
        }
    }

    function uploadFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (file) {
                const formData = new FormData();
                formData.append('file', file);
                try {
                    const res = await fetch('/upload', {
                        method: 'POST',
                        body: formData
                    });
                    const text = await res.text();
                    const copyResult = copyText(text) ? " And The path copied to clipboard!" : "!";
                    alert(`Upload successful${copyResult}\n${text}`);
                    initFiles();
                } catch (err) {
                    alert("Error uploading file: " + err);
                }
            }
        };
        input.click();
    }
</script>
</body>
</html>